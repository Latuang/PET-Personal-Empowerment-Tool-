<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PET Control Panel</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    :root{
      --ink:#2b2118;
      --paper:#ffffffee;
      --bg-a:#fff4ea;     /* warm peach */
      --bg-b:#fde9f2;     /* rosy milk */
      --bg-c:#e9fbf1;     /* mint foam */
      --peach:#ff8c7a;    /* Save */
      --teal:#3f8e7b;     /* Load */
      --ring: 0 0 0 3px color-mix(in oklab, #ff8c7a, white 70%);
      --shadow: 0 18px 50px rgba(60,38,21,.15), 0 4px 16px rgba(60,38,21,.08);
      --radius: 22px;
      --accent:#6b8f86;   /* timer chrome */
      --accent2:#ffb6a6;  /* progress gradient end */
      --muted:#6b5c52;
    }

    html,body{height:100%}
    body{
      margin:0; color:var(--ink);
      font:16px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: linear-gradient(180deg, var(--bg-a), var(--bg-b) 40%, var(--bg-c) 100%);
      overflow-x:hidden;
    }

    /* ===== animated background (very subtle) ===== */
    canvas#bg{ position:fixed; inset:0; z-index:0; pointer-events:none; opacity:.6 }
    /* faint twinkle dots */
    .fireflies{
      position:fixed; inset:0; z-index:0; pointer-events:none;
      background:
        radial-gradient(6px 6px at 12% 70%, rgba(255,255,255,.55), transparent 60%),
        radial-gradient(5px 5px at 60% 20%, rgba(255,255,255,.45), transparent 60%),
        radial-gradient(4px 4px at 80% 80%, rgba(255,255,255,.4),  transparent 60%),
        radial-gradient(6px 6px at 30% 35%, rgba(255,255,255,.5),  transparent 60%);
      animation: twinkle 7s ease-in-out infinite alternate;
      mix-blend-mode: screen;
      opacity:.45;
    }
    @keyframes twinkle{
      0%{ filter: blur(.6px) brightness(1) }
      100%{ filter: blur(1.2px) brightness(1.25) }
    }

    /* ===== card ===== */
    .wrap{
      position:relative; z-index:1;
      max-width: 860px;
      margin: clamp(18px, 6vh, 56px) auto;
      padding: clamp(18px, 3.8vw, 28px);
      border-radius: var(--radius);
      background: var(--paper);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
    }

    .header{ display:flex; align-items:center; gap:14px; margin:0 0 8px; }
    h1{ margin:0; font-size: clamp(22px, 2.6vw, 32px); letter-spacing:.2px; }
    .sub{ color:var(--muted); margin:0 0 14px; }

    /* text field */
    .field{
      margin-top: 12px;
      border-radius: 16px;
      border:1px solid #e8d9cc;
      background:#fffdfb;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.7);
      overflow:hidden;
    }
    textarea{
      display:block; width:100%; min-height: 240px;
      padding:14px 14px 16px; border:0; outline:0; box-sizing:border-box;
      font: 15px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      background:transparent; color:var(--ink);
    }

    .row{ display:flex; flex-wrap:wrap; gap:12px; margin-top:14px; }

    .btn{
      --bg:#2b2118; --txt:#fff;
      appearance:none; border:0; cursor:pointer;
      padding:12px 16px; border-radius:14px; color:var(--txt); font-weight:650; letter-spacing:.15px;
      background: radial-gradient(120% 140% at 10% 10%, color-mix(in oklab, var(--bg), black 7%) 0 25%, var(--bg) 26% 100%);
      position:relative; transform: translateZ(0);
      transition: transform .06s ease, filter .25s ease, box-shadow .25s ease;
      box-shadow: 0 6px 18px rgba(43,33,24,.18), inset 0 1px 0 rgba(255,255,255,.2);
      overflow:hidden;
    }
    .btn:hover{ filter: brightness(1.06); box-shadow: 0 10px 28px rgba(43,33,24,.25), 0 0 24px 6px color-mix(in oklab, var(--bg), white 75%); }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.peach{ --bg: var(--peach); }
    .btn.teal { --bg: var(--teal); }
    .btn.ghost{ --bg:#fff; --txt:var(--ink); border:1px solid #e7d9cc; background:#fff; box-shadow:none; }
    .btn.is-sending{ animation: throb .9s ease-in-out infinite; }
    @keyframes throb { 50% { transform: translateY(0) scale(1.03) } }
    .btn .r{ position:absolute; width:8px;height:8px;border-radius:999px; background:#fff8; transform: translate(-50%,-50%) scale(0); animation: ripple .6s ease-out; pointer-events:none; }
    @keyframes ripple{ to { transform: translate(-50%,-50%) scale(22); opacity:0 } }

    .hint{ font-size:13px; color:var(--muted); margin-top:8px;}
    .ok { color:#0f7d4c; }
    .err{ color:#b00020; }

    .badges{ display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; align-items:center; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; background:#fff8f1; border:1px solid #f2decf; color:#5c4a3c; border-radius: 999px; font-size:12px;
    }
    .dot{ width:10px;height:10px;border-radius:50%; background:#ffb39f; box-shadow:0 0 10px #ffb39f; }
    .dot.mint{ background:#a8e4d2; box-shadow:0 0 10px #a8e4d2; }

    /* ===== Timer section ===== */
    .timer{
      margin-top:20px; padding:16px; border-radius:16px;
      border:1px solid #e7dccf; background: #fffdfb;
    }
    .timer .title{ display:flex; gap:8px; align-items:center; margin:0 0 10px; color:var(--ink); font-weight:650; }
    .t-grid{ display:grid; grid-template-columns: 130px 1fr; gap:16px; align-items:center; }
    .time-inputs{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .ti{
      display:flex; flex-direction:column; gap:6px; min-width:84px;
    }
    .ti label{ font-size:12px; color:var(--muted); }
    .ti input{
      width:100%; appearance:textfield; -moz-appearance:textfield;
      padding:10px 12px; border-radius:12px; border:1px solid #e2d6c9; background:#fff;
      font:600 16px/1 ui-sans-serif, system-ui; color:#2b2118; text-align:center;
      transition: box-shadow .2s ease, border-color .2s ease;
    }
    .ti input:focus{ outline:none; border-color:#d8cabc; box-shadow:0 0 0 4px rgba(211,192,176,.25); }

    .controls{ display:flex; gap:10px; flex-wrap:wrap; }
    .presets{ display:flex; gap:8px; flex-wrap:wrap; }

    /* progress ring */
    .ring{
      --p: 0; /* 0..1 */
      width:96px; height:96px; border-radius:50%;
      background:
        conic-gradient(from -90deg, color-mix(in oklab, var(--accent), white 12%) calc(var(--p)*1turn),
                                 #eee 0),
        radial-gradient(circle at 50% 50%, #fff 62%, transparent 63%);
      border:1px solid #e2d6c9;
      display:grid; place-items:center;
      transition: background .35s ease;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.7);
    }
    .ring .mm{
      font: 700 18px/1.1 ui-sans-serif, system-ui;
      color: var(--accent);
    }

    @media (max-width:740px){ .t-grid{ grid-template-columns: 1fr; } }
    @media (max-width:560px){ .wrap{ margin:18px 12px } }
  </style>
</head>
<body>
  <!-- animated layers -->
  <canvas id="bg" aria-hidden="true"></canvas>
  <div class="fireflies" aria-hidden="true"></div>

  <main class="wrap" role="main">
    <div class="header">
      <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M6 7h12M6 12h9M6 17h6" stroke="#2b2118" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <div>
        <h1>Welcome to PET Control Panel</h1>
        <p class="sub">PET aka Personal Empowerment Tool will cheer you on across your tabs.</p>
        <p class="sub">Instruction: Add pep lines below for your PET. One line per row.</p>
      </div>
    </div>

    <div class="field">
      <textarea id="lines" placeholder="E.g.
Drink water. Breathe. Send that message.
Tiny step now, future you says thanks."></textarea>
    </div>

    <div class="row">
      <button id="save" class="btn peach">Save to PET ‚ú®</button>
      <button id="load" class="btn teal">Load from PET üçÉ</button>
    </div>

    <!-- ===== Timer ===== -->
    <section class="timer" aria-labelledby="timer-title">
      <div class="title" id="timer-title">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M9 2h6M12 8v6l4 2" stroke="#6b8f86" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="14" r="7" stroke="#6b8f86" stroke-width="2"/></svg>
        <span>Timer</span>
      </div>

      <div class="t-grid">
        <div class="ring" id="ring"><div class="mm" id="mm">00:00</div></div>

        <div>
          <div class="time-inputs">
            <div class="ti">
              <label for="hh">Hours</label>
              <input id="hh" type="number" min="0" max="23" value="0" inputmode="numeric">
            </div>
            <div class="ti">
              <label for="mi">Minutes</label>
              <input id="mi" type="number" min="0" max="59" value="25" inputmode="numeric">
            </div>
            <div class="ti">
              <label for="ss">Seconds</label>
              <input id="ss" type="number" min="0" max="59" value="0" inputmode="numeric">
            </div>
          </div>

          <div class="row" style="margin-top:12px">
            <div class="controls">
              <button class="btn ghost" id="start">Start</button>
              <button class="btn ghost" id="pause">Pause</button>
              <button class="btn ghost" id="reset">Reset</button>
            </div>
            <div class="presets">
              <button class="btn ghost" data-preset="300">5 min</button>
              <button class="btn ghost" data-preset="1500">25 min</button>
            </div>
          </div>

          <div class="hint" id="tstatus" role="status" aria-live="polite"></div>
        </div>
      </div>
    </section>

    <div id="status" class="hint" role="status" aria-live="polite"></div>

    <div class="badges">
      <span class="chip"><span class="dot"></span> Works in Google Chrome (desktop)</span>
      <span class="chip"><span class="dot mint"></span> Requires PET extension installed</span>
    </div>
  </main>

  <script>
    /*** Subtle animated background (soft drifting blobs) ***/
    const c = document.getElementById('bg');
    const ctx = c.getContext('2d');
    let W, H, blobs;

    function reset(){
      W = c.width  = innerWidth * devicePixelRatio;
      H = c.height = innerHeight* devicePixelRatio;
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      blobs = Array.from({length: 8}, (_,i)=>({
        x: Math.random()*innerWidth,
        y: Math.random()*innerHeight,
        r: 80 + Math.random()*140,
        hue: [22,340,160][i%3], alpha: .18 + Math.random()*.16,
        vx: (Math.random()-.5)*0.18, vy: (Math.random()-.5)*0.18
      }));
    }
    reset(); addEventListener('resize', reset);

    function tick(){
      ctx.clearRect(0,0,innerWidth,innerHeight);
      blobs.forEach(b=>{
        b.x += b.vx; b.y += b.vy;
        if (b.x<-b.r) b.x=innerWidth+b.r; if (b.x>innerWidth+b.r) b.x=-b.r;
        if (b.y<-b.r) b.y=innerHeight+b.r; if (b.y>innerHeight+b.r) b.y=-b.r;
        const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
        g.addColorStop(0, `hsla(${b.hue} 92% 75% / ${b.alpha})`);
        g.addColorStop(1, `hsla(${b.hue} 92% 75% / 0)`);
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      });
      requestAnimationFrame(tick);
    }
    tick();

    /*** PET messaging ***/
    const EXT_ID = "libkjkfhpilbfmcbknhnhnfejacjkccd"; // your real extension ID
    const statusEl = document.getElementById('status');
    const linesEl  = document.getElementById('lines');
    const saveBtn  = document.getElementById('save');
    const loadBtn  = document.getElementById('load');

    const canUseAPI = () =>
      typeof chrome !== "undefined" && chrome.runtime && typeof chrome.runtime.sendMessage === "function";

    const say = (txt, ok=true)=>{
      statusEl.textContent = txt;
      statusEl.className = "hint " + (ok? "ok":"err");
    };

    const getLines = () =>
      linesEl.value.split('\n').map(s => s.trim()).filter(Boolean);

    function sendToPET(payload, cb) {
      if (!canUseAPI()) { say("Chrome API not available. Use Google Chrome on desktop.", false); cb?.(null); return; }
      chrome.runtime.sendMessage(EXT_ID, payload, (resp) => {
        if (chrome.runtime.lastError) { say("Could not reach PET: " + chrome.runtime.lastError.message, false); cb?.(null); return; }
        cb?.(resp);
      });
    }

    function ripple(e){
      const r=document.createElement('span'); r.className='r'; e.currentTarget.appendChild(r);
      r.style.left = e.offsetX+'px'; r.style.top = e.offsetY+'px';
      r.addEventListener('animationend', ()=>r.remove());
    }
    [saveBtn, loadBtn].forEach(b=>b.addEventListener('click', ripple));

    function confetti(){
      const N=28;
      for(let i=0;i<N;i++){
        const s=document.createElement('div'); const size = 6+Math.random()*8;
        s.textContent = ['‚ú®','üê∂','üåü','üíñ','üçÄ'][i%5];
        s.style.position='fixed'; s.style.zIndex=9999; s.style.left=(Math.random()*100)+'vw'; s.style.top='-10vh';
        s.style.fontSize=size+'px'; s.style.transition='transform 1.2s ease-out, opacity 1.2s ease-out';
        document.body.appendChild(s);
        requestAnimationFrame(()=>{ s.style.transform=`translateY(${110+Math.random()*20}vh) rotate(${(Math.random()-.5)*360}deg)`; s.style.opacity='0'; });
        setTimeout(()=>s.remove(),1300);
      }
    }

    saveBtn.addEventListener('click', () => {
      const lines = getLines();
      if (!lines.length) { say("Add at least one line.", false); return; }
      const sayNow = lines[lines.length - 1];
      saveBtn.classList.add('is-sending'); saveBtn.disabled = true;

      sendToPET({ type: "PET_ADD_LINES", lines }, (resp) => {
        saveBtn.classList.remove('is-sending'); saveBtn.disabled = false;
        if (!(resp && resp.ok)) { say("PET error: " + (resp?.error || "Unknown"), false); return; }
        sendToPET({ type: "PET_SAY_NOW", text: sayNow }, (resp2) => {
          if (resp2?.ok) { say(`Saved & said: ‚Äú${sayNow}‚Äù`); confetti(); }
          else { say("Saved, but could not trigger speech.", false); }
        });
      });
    });

    loadBtn.addEventListener('click', () => {
      loadBtn.classList.add('is-sending'); loadBtn.disabled = true;
      sendToPET({ type: "PET_GET_LINES" }, (resp) => {
        loadBtn.classList.remove('is-sending'); loadBtn.disabled = false;
        if (resp?.ok) { linesEl.value = (resp.lines || []).join('\n'); say(`Loaded ${resp.lines?.length || 0} lines from PET.`); }
        else { say("PET error: " + (resp?.error || "Unknown"), false); }
      });
    });

    window.addEventListener('DOMContentLoaded', () => {
      if (!canUseAPI()) { say("Chrome API not available. Use Google Chrome on desktop.", false); return; }
      sendToPET({ type: "PET_GET_LINES" }, (resp) => {
        if (resp?.ok) { linesEl.value = (resp.lines || []).join('\n'); say(`Connected to PET. ${resp.lines?.length || 0} custom lines loaded.`); }
        else { say("Could not connect to PET. Check manifest origins and reload the extension.", false); }
      });
    });

    /*** Timer logic ***/
    const hh=document.getElementById('hh'), mi=document.getElementById('mi'), ss=document.getElementById('ss');
    const ring=document.getElementById('ring'), mm=document.getElementById('mm'), tstatus=document.getElementById('tstatus');
    const start=document.getElementById('start'), pause=document.getElementById('pause'), reset=document.getElementById('reset');
    document.querySelectorAll('[data-preset]').forEach(b=>b.addEventListener('click',e=>{
      const total=+e.currentTarget.dataset.preset|0; setInputsFromSeconds(total); updateDisplay(total,total);
    }));

    let totalMs=0, remainingMs=0, running=false, lastTick=0, rafId=0;

    function clamp(n,min,max){ return Math.min(max, Math.max(min, n)); }
    function toSeconds(){ return (clamp(+hh.value||0,0,23)*3600)+(clamp(+mi.value||0,0,59)*60)+(clamp(+ss.value||0,0,59)); }
    function setInputsFromSeconds(s){
      const h=Math.floor(s/3600), m=Math.floor((s%3600)/60), sec=s%60;
      hh.value=h; mi.value=m; ss.value=sec;
    }
    function fmt(t){ return String(t).padStart(2,'0'); }

    function updateDisplay(rem,total){
      const p = total>0 ? (1 - (rem/total)) : 0;
      ring.style.setProperty('--p', p);
      const rh=Math.floor(rem/3600), rm=Math.floor((rem%3600)/60), rs=Math.floor(rem%60);
      mm.textContent = `${fmt(rh>0?rh:rm)}:${fmt(rh>0?rm:rs)}`;
    }

    function setRunning(v){
      running=v;
      [hh,mi,ss].forEach(i=>i.disabled=v);
      start.textContent = v ? 'Running‚Ä¶' : 'Start';
    }

    function startTimer(){
      totalMs = Math.max(1000, toSeconds()*1000);
      remainingMs = totalMs;
      lastTick = performance.now();
      setRunning(true);
      tickTimer();
      tstatus.textContent = 'Timer started.';
    }
    function pauseTimer(){ setRunning(false); cancelAnimationFrame(rafId); tstatus.textContent='Paused.'; }
    function resetTimer(){
      cancelAnimationFrame(rafId); setRunning(false);
      const s = toSeconds(); remainingMs = s*1000; updateDisplay(s, s||1);
      tstatus.textContent='Reset.';
    }

    function tickTimer(now=performance.now()){
      if(!running){ return; }
      const dt = now - lastTick; lastTick = now;
      remainingMs -= dt;
      if (remainingMs <= 0){
        remainingMs=0; updateDisplay(0, totalMs);
        doneTimer();
        return;
      }
      updateDisplay(Math.ceil(remainingMs/1000), totalMs/1000);
      rafId = requestAnimationFrame(tickTimer);
    }

    function doneTimer(){
      setRunning(false);
      chime();
      // Ask PET to speak everywhere
      sendToPET({ type: "PET_SAY_NOW", text: "Time‚Äôs up!" }, ()=>{});
      tstatus.textContent='Time‚Äôs up!';
    }

    // Gentle chime using WebAudio (no external files)
    function chime(){
      try{
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        const seq = [880, 1318, 1760]; // A5, E6, A6
        let t = ac.currentTime;
        seq.forEach((f,i)=>{
          const o=ac.createOscillator(), g=ac.createGain();
          o.type='sine'; o.frequency.value=f;
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(0.12, t+0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
          o.connect(g).connect(ac.destination);
          o.start(t); o.stop(t+0.36);
          t += 0.12;
        });
      }catch(e){}
    }

    start.addEventListener('click', ()=>{
      const secs = toSeconds();
      if (!secs){ tstatus.textContent='Enter a time first.'; return; }
      startTimer();
    });
    pause.addEventListener('click', pauseTimer);
    reset.addEventListener('click', resetTimer);

    // initialize their display to inputs
    resetTimer();
  </script>
</body>
</html>

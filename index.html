<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PET Control Panel</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    :root{
      --ink:#2b2118;
      --paper:#ffffffee;

      /* soft background gradient */
      --bg-a:#fff4ea;     /* warm peach */
      --bg-b:#fde9f2;     /* rosy milk */
      --bg-c:#e9fbf1;     /* mint foam */

      /* brand tints */
      --peach:#ff8c7a;    /* Save */
      --teal:#3f8e7b;     /* Load */
      --mint:#a8e4d2;

      --shadow: 0 18px 50px rgba(60,38,21,.12), 0 4px 16px rgba(60,38,21,.08);
      --radius: 22px;

      /* timer colors */
      --ring: #e9dcd2;
      --ring-active: #3f8e7b;
      --tick:#d9cfc7;
    }

    html,body{height:100%}
    body{
      margin:0; color:var(--ink);
      font:16px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: linear-gradient(180deg, var(--bg-a), var(--bg-b) 40%, var(--bg-c) 100%);
      overflow-x:hidden;
    }

    /* gentle drifting blobs (very subtle) */
    canvas#bg{ position:fixed; inset:0; z-index:0; pointer-events:none; opacity:.75 }

    .wrap{
      position:relative; z-index:1;
      max-width: 980px;
      margin: clamp(18px, 6vh, 56px) auto;
      padding: clamp(18px, 3.8vw, 28px);
      border-radius: var(--radius);
      background: var(--paper);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
    }

    .header{ display:flex; align-items:center; gap:14px; margin:0 0 8px; }
    h1{ margin:0; font-size: clamp(22px, 2.6vw, 32px); letter-spacing:.2px; }
    .sub{ color:#6b5c52; margin:0 0 14px; }

    .field{
      margin-top: 12px;
      border-radius: 16px;
      border:1px solid #e8d9cc;
      background:#fffdfb;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.7);
      overflow:hidden;
    }
    textarea{
      display:block;
      width:100%;
      min-height: 240px;
      padding:14px 14px 16px;
      border:0; outline:0;
      box-sizing:border-box;
      font: 15px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      background:transparent; color:var(--ink);
    }

    .row{ display:flex; flex-wrap:wrap; gap:12px; margin-top:14px; }

    .btn{
      --bg:#2b2118; --txt:#fff;
      appearance:none; border:0; cursor:pointer;
      padding:12px 16px; border-radius:14px;
      color:var(--txt); font-weight:650; letter-spacing:.15px;
      background: radial-gradient(120% 140% at 10% 10%, color-mix(in oklab, var(--bg), black 7%) 0 25%, var(--bg) 26% 100%);
      position:relative; transform: translateZ(0);
      transition: transform .06s ease, filter .25s ease, box-shadow .25s ease;
      box-shadow: 0 6px 18px rgba(43,33,24,.18), inset 0 1px 0 rgba(255,255,255,.2);
      overflow:hidden;
    }
    .btn:hover{
      filter: brightness(1.06);
      box-shadow: 0 10px 28px rgba(43,33,24,.25), 0 0 24px 6px color-mix(in oklab, var(--bg), white 75%);
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.peach{ --bg: var(--peach); }
    .btn.teal { --bg: var(--teal); }

    .btn .r{ position:absolute; width:8px;height:8px;border-radius:999px;
      background:#fff8; transform: translate(-50%,-50%) scale(0);
      animation: ripple .6s ease-out; pointer-events:none; }
    @keyframes ripple{ to { transform: translate(-50%,-50%) scale(22); opacity:0 } }

    .hint{ font-size:13px; color:#6b5c52; margin-top:10px;}
    .ok { color:#0f7d4c; }
    .err{ color:#b00020; }

    .badges{ display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; align-items:center; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; background:#fff8f1; border:1px solid #f2decf;
      color:#5c4a3c; border-radius: 999px; font-size:12px;
    }
    .dot{ width:10px;height:10px;border-radius:50%; background:#ffb39f; box-shadow:0 0 10px #ffb39f; }
    .dot.mint{ background:#a8e4d2; box-shadow:0 0 10px #a8e4d2; }

    /* ===== Timer card ===== */
    .timer{
      margin-top: 18px;
      border:1px solid #f0e4d9;
      border-radius: 18px;
      background:#fffbf7;
      padding:18px;
    }
    .timer h2{
      margin: 0 0 14px;
      font-size: 20px;
      display:flex; align-items:center; gap:10px;
    }

    .t-grid{
      display:grid;
      grid-template-columns: 270px 1fr;
      gap:22px;
      align-items:center;
    }

    /* circular clock */
    .clock{
      width: 260px; height: 260px;
      display:grid; place-items:center;
      position:relative;
    }
    .clock svg{ width:100%; height:100%; }
    .ticks line{ stroke: var(--tick); stroke-width:1 }
    .ring-bg{ stroke: var(--ring); stroke-width:14; fill:none; }
    .ring{ stroke: var(--ring-active); stroke-width:14; fill:none; stroke-linecap:round;
           transform: rotate(-90deg); transform-origin: 50% 50%; transition: stroke-dashoffset .25s ease; }
    .hand{ stroke: #6b5c52; stroke-width:3; stroke-linecap:round;
           transform-origin: 50% 50%; transition: transform .25s ease; }
    .face-drop{ filter: drop-shadow(0 8px 24px rgba(0,0,0,.08)); }

    .clock-label{
      position:absolute; inset:auto 0 36px 0; display:grid; place-items:center;
      font-weight:700; letter-spacing:.5px; color:#2b2118;
      font-size: 28px;
    }

    /* input + actions */
    .inputs{
      display:grid; grid-template-columns: repeat(3, minmax(120px, 1fr));
      gap:14px; align-self:start;
    }
    .ibox{
      border:1px solid #e8d9cc; border-radius:14px; background:#fff;
      padding:10px 12px;
    }
    .ibox label{ display:block; font-size:12px; color:#6b5c52; margin-bottom:6px }
    .ibox input{
      width:100%; font: 600 20px/1.2 ui-sans-serif, system-ui; text-align:center;
      border:0; outline:0; background:transparent; color:#2b2118;
    }

    .actions{
      margin-top: 16px;
      display:flex; gap:12px; justify-content:flex-end; flex-wrap:wrap;
    }
    .pill{
      border-radius: 14px; padding:10px 14px; background:#fff; border:1px solid #e8d9cc;
      font-weight:600; cursor:pointer;
      box-shadow: 0 3px 10px rgba(0,0,0,.04);
      transition: background .2s, transform .06s;
    }
    .pill:active{ transform: translateY(1px) }
    .pill.peachish{ background: #ffe9e3 }
    .pill.mintish{ background: #e8f7f1 }

    @media (max-width:900px){
      .t-grid{ grid-template-columns: 1fr; }
      .clock{ margin: 0 auto }
      .actions{ justify-content:flex-start }
    }
  </style>
</head>
<body>
  <!-- subtle animated background -->
  <canvas id="bg" aria-hidden="true"></canvas>

  <main class="wrap" role="main">
    <div class="header">
      <svg width="28" height="28" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M6 7h12M6 12h9M6 17h6" stroke="#2b2118" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <div>
        <h1>Welcome to PET Control Panel</h1>
        <p class="sub">PET aka Personal Empowerment Tool will cheer you on across your tabs.</p>
        <p class="sub">Instruction: Add pep lines below for your PET. One line per row.</p>
      </div>
    </div>

    <div class="field">
      <textarea id="lines" placeholder="E.g.
Drink water. Breathe. Send that message.
Tiny step now, future you says thanks."></textarea>
    </div>

    <div class="row">
      <button id="save" class="btn peach">Save to PET ‚ú®</button>
      <button id="load" class="btn teal">Load from PET üçÉ</button>
    </div>

    <section class="timer" aria-label="Timer">
      <h2>‚è≤Ô∏è Timer</h2>
      <div class="t-grid">
        <!-- Clock -->
        <div class="clock" aria-live="polite">
          <svg viewBox="0 0 200 200" class="face-drop">
            <!-- minute ticks -->
            <g class="ticks">
              <!-- 60 ticks -->
              <script type="application/ecmascript"><![CDATA[
                // (kept empty; ticks drawn by JS below)
              ]]></script>
            </g>
            <circle class="ring-bg" cx="100" cy="100" r="78"/>
            <circle class="ring" id="ring" cx="100" cy="100" r="78" stroke-dasharray="490" stroke-dashoffset="0"/>
            <line class="hand" id="hand" x1="100" y1="100" x2="100" y2="36"/>
          </svg>
          <div class="clock-label" id="lcd">00:00</div>
        </div>

        <!-- Inputs + Buttons -->
        <div>
          <div class="inputs">
            <div class="ibox"><label>Hours</label>   <input id="h" type="number" min="0" value="0"></div>
            <div class="ibox"><label>Minutes</label> <input id="m" type="number" min="0" value="25"></div>
            <div class="ibox"><label>Seconds</label> <input id="s" type="number" min="0" value="0"></div>
          </div>

          <div class="actions">
            <button class="pill peachish" id="start">Start</button>
            <button class="pill mintish" id="pause">Pause</button>
            <button class="pill" id="reset">Reset</button>
            <button class="pill" id="p5">5 min</button>
            <button class="pill" id="p25">25 min</button>
          </div>
        </div>
      </div>
    </section>

    <div id="status" class="hint" role="status" aria-live="polite"></div>

    <div class="badges">
      <span class="chip"><span class="dot"></span> Works in Google Chrome (desktop)</span>
      <span class="chip"><span class="dot mint"></span> Requires PET extension installed</span>
    </div>
  </main>

  <script>
    /* ---------- Subtle background blobs ---------- */
    const c = document.getElementById('bg');
    const ctx = c.getContext('2d');
    let W, H, blobs;

    function resetBG(){
      W = c.width  = innerWidth * devicePixelRatio;
      H = c.height = innerHeight* devicePixelRatio;
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      blobs = Array.from({length: 9}, (_,i)=>({
        x: Math.random()*innerWidth,
        y: Math.random()*innerHeight,
        r: 120 + Math.random()*160,
        hue: [22,340,160][i%3], alpha: .16 + Math.random()*.12,
        vx: (Math.random()-.5)*0.15, vy: (Math.random()-.5)*0.15
      }));
    }
    resetBG(); addEventListener('resize', resetBG);
    let mx = innerWidth/2, my = innerHeight/2;
    addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });

    (function bgTick(){
      ctx.clearRect(0,0,innerWidth,innerHeight);
      blobs.forEach(b=>{
        b.x += b.vx; b.y += b.vy;
        if (b.x<-b.r) b.x=innerWidth+b.r;
        if (b.x>innerWidth+b.r) b.x=-b.r;
        if (b.y<-b.r) b.y=innerHeight+b.r;
        if (b.y>innerHeight+b.r) b.y=-b.r;
        b.x += (mx-b.x)*0.0015; b.y += (my-b.y)*0.0015;
        const g = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r);
        g.addColorStop(0, `hsla(${b.hue} 92% 75% / ${b.alpha})`);
        g.addColorStop(1, `hsla(${b.hue} 92% 75% / 0)`);
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
      });
      requestAnimationFrame(bgTick);
    })();

    /* ---------- PET wiring (unchanged) ---------- */
    const EXT_ID = "libkjkfhpilbfmcbknhnhnfejacjkccd"; // your extension id
    const statusEl = document.getElementById('status');
    const linesEl  = document.getElementById('lines');
    const saveBtn  = document.getElementById('save');
    const loadBtn  = document.getElementById('load');

    const canUseAPI = () =>
      typeof chrome !== "undefined" && chrome.runtime && typeof chrome.runtime.sendMessage === "function";

    const say = (txt, ok=true)=>{ statusEl.textContent = txt; statusEl.className = "hint " + (ok? "ok":"err"); };
    const getLines = () => linesEl.value.split('\n').map(s => s.trim()).filter(Boolean);

    function sendToPET(payload, cb) {
      if (!canUseAPI()) { say("Chrome API not available. Use Google Chrome on desktop.", false); cb?.(null); return; }
      chrome.runtime.sendMessage(EXT_ID, payload, (resp) => {
        if (chrome.runtime.lastError) { say("Could not reach PET: " + chrome.runtime.lastError.message, false); cb?.(null); return; }
        cb?.(resp);
      });
    }

    function ripple(e){
      const r=document.createElement('span'); r.className='r'; e.currentTarget.appendChild(r);
      r.style.left = e.offsetX+'px'; r.style.top = e.offsetY+'px';
      r.addEventListener('animationend', ()=>r.remove());
    }
    [saveBtn, loadBtn].forEach(b=>b.addEventListener('click', ripple));

    function confetti(){
      const N=28;
      for(let i=0;i<N;i++){
        const s=document.createElement('div');
        const size = 6+Math.random()*8;
        s.textContent = ['‚ú®','üê∂','üåü','üíñ','üçÄ'][i%5];
        s.style.position='fixed'; s.style.zIndex=9999;
        s.style.left=(Math.random()*100)+'vw'; s.style.top='-10vh';
        s.style.fontSize=size+'px'; s.style.transition='transform 1.2s ease-out, opacity 1.2s ease-out';
        document.body.appendChild(s);
        requestAnimationFrame(()=>{
          s.style.transform=`translateY(${110+Math.random()*20}vh) rotate(${(Math.random()-.5)*360}deg)`;
          s.style.opacity='0';
        });
        setTimeout(()=>s.remove(),1300);
      }
    }

    saveBtn.addEventListener('click', () => {
      const lines = getLines();
      if (!lines.length) { say("Add at least one line.", false); return; }
      const sayNow = lines[lines.length - 1];
      saveBtn.disabled = true; saveBtn.classList.add('is-sending');
      sendToPET({ type: "PET_ADD_LINES", lines }, (resp) => {
        saveBtn.disabled = false; saveBtn.classList.remove('is-sending');
        if (!(resp && resp.ok)) { say("PET error: " + (resp?.error || "Unknown"), false); return; }
        sendToPET({ type: "PET_SAY_NOW", text: sayNow }, (r2) => {
          if (r2?.ok) { say(`Saved & said: ‚Äú${sayNow}‚Äù`); confetti(); }
          else { say("Saved, but could not trigger speech.", false); }
        });
      });
    });

    loadBtn.addEventListener('click', () => {
      loadBtn.disabled = true; loadBtn.classList.add('is-sending');
      sendToPET({ type: "PET_GET_LINES" }, (resp) => {
        loadBtn.disabled = false; loadBtn.classList.remove('is-sending');
        if (resp?.ok) { linesEl.value = (resp.lines || []).join('\n'); say(`Loaded ${resp.lines?.length || 0} lines from PET.`); }
        else { say("PET error: " + (resp?.error || "Unknown"), false); }
      });
    });

    window.addEventListener('DOMContentLoaded', () => {
      if (!canUseAPI()) { say("Chrome API not available. Use Google Chrome on desktop.", false); return; }
      sendToPET({ type: "PET_GET_LINES" }, (resp) => {
        if (resp?.ok) { linesEl.value = (resp.lines || []).join('\n'); say(`Connected to PET. ${resp.lines?.length || 0} custom lines loaded.`); }
        else { say("Could not connect to PET. Check manifest origins and reload the extension.", false); }
      });
    });

    /* ---------- Timer logic + cute chime ---------- */
    const lcd = document.getElementById('lcd');
    const ring = document.getElementById('ring');
    const hand = document.getElementById('hand');
    const hEl = document.getElementById('h'), mEl = document.getElementById('m'), sEl = document.getElementById('s');
    const startBtn = document.getElementById('start'), pauseBtn = document.getElementById('pause');
    const resetBtn = document.getElementById('reset'), p5 = document.getElementById('p5'), p25 = document.getElementById('p25');

    const CIRC = 2*Math.PI*78;              // circumference of circle (r=78)
    ring.setAttribute('stroke-dasharray', CIRC);
    ring.style.strokeDashoffset = 0;

    // draw minute ticks
    (function drawTicks(){
      const svg = ring.closest('svg');
      const g = svg.querySelector('.ticks');
      for(let i=0;i<60;i++){
        const ang = (i/60)*2*Math.PI;
        const r1 = i%5===0? 86: 88, r2 = i%5===0? 92: 90;
        const x1 = 100 + Math.cos(ang- Math.PI/2)*r1;
        const y1 = 100 + Math.sin(ang- Math.PI/2)*r1;
        const x2 = 100 + Math.cos(ang- Math.PI/2)*r2;
        const y2 = 100 + Math.sin(ang- Math.PI/2)*r2;
        const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
        ln.setAttribute('x1',x1);ln.setAttribute('y1',y1);ln.setAttribute('x2',x2);ln.setAttribute('y2',y2);
        g.appendChild(ln);
      }
    })();

    let total = 25*60, left = total, running = false, tickT = null, audioCtx=null;

    function fmt(n){ return String(n).padStart(2,'0'); }

    function setFromInputs(){
      const h = Math.max(0, parseInt(hEl.value||'0',10));
      const m = Math.max(0, parseInt(mEl.value||'0',10));
      const s = Math.max(0, parseInt(sEl.value||'0',10));
      total = left = h*3600 + m*60 + s;
      paint();
    }

    function paint(){
      const mm = Math.floor(left/60), ss = left%60;
      lcd.textContent = `${fmt(mm)}:${fmt(ss)}`;
      const progress = total>0 ? (1 - left/total) : 1;
      ring.style.strokeDashoffset = String(progress*CIRC);
      const angle = 360*progress;
      hand.style.transform = `rotate(${angle}deg)`;
    }

    function ensureAudio(){
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    // cute repeating chime ~4s
    function ringCute(ms=4000){
      ensureAudio();
      const startAt = audioCtx.currentTime;
      const beat = 0.35;                 // 350ms per blip
      const reps = Math.floor(ms/ (beat*1000));
      for (let i=0;i<reps;i++){
        const t = startAt + i*beat;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = 880 - (i%2)*120; // alternate pitch
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.24, t+0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t+0.25);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t);
        osc.stop(t+0.28);
      }
    }

    function done(){
      running = false;
      clearInterval(tickT);
      tickT = null;
      left = 0; paint();
      // Tell PET on all tabs
      sendToPET({ type: "PET_SAY_NOW", text: "Time's up!" }, ()=>{});
      // Play chime ~4s
      ringCute(4000);
    }

    function start(){
      if (left<=0) setFromInputs();
      if (left<=0) return;
      ensureAudio(); // user gesture ‚Äì enables audio later
      if (running) return;
      running = true;
      const start = Date.now();
      let prev = start;
      tickT = setInterval(()=>{
        const now = Date.now();
        if (now - prev >= 1000){
          left = Math.max(0, left - 1);
          paint();
          prev = now;
          if (left===0) done();
        }
      }, 200);
    }

    function pause(){ running=false; clearInterval(tickT); tickT=null; }
    function reset(){ pause(); setFromInputs(); }

    startBtn.addEventListener('click', start);
    pauseBtn.addEventListener('click', pause);
    resetBtn.addEventListener('click', reset);
    p5.addEventListener('click', ()=>{ hEl.value=0; mEl.value=5; sEl.value=0; setFromInputs(); });
    p25.addEventListener('click', ()=>{ hEl.value=0; mEl.value=25; sEl.value=0; setFromInputs(); });
    [hEl,mEl,sEl].forEach(i=> i.addEventListener('change', setFromInputs));

    // init
    setFromInputs();

    /* initial PET check */
    window.addEventListener('DOMContentLoaded', () => {
      if (!canUseAPI()) { say("Chrome API not available. Use Google Chrome on desktop.", false); return; }
      sendToPET({ type: "PET_GET_LINES" }, (resp) => {
        if (resp?.ok) {
          linesEl.value = (resp.lines || []).join('\n');
          say(`Connected to PET. ${resp.lines?.length || 0} custom lines loaded.`);
        } else {
          say("Could not connect to PET. Check manifest origins and reload the extension.", false);
        }
      });
    });
  </script>
</body>
</html>
